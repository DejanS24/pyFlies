/*
  This is a textX specification of pyFlies DSL for Reaction Time test
  experiments definition.
  Author: Igor R. Dejanovic <igor DOT dejanovic AT gmail DOT com>
  Copyright: (c) 2014 Igor R. Dejanovic <igor DOT dejanovic AT gmail DOT com>
  License: MIT License
*/

PyFliesModel:
  ("basepath" basepath=STRING)?
  elements+=ModelElement
;

ModelElement:
  TestType|Experiment|TextType|SubjectType|Target
;

TestType:
  "test" name=ID "{"
    (conditions = Conditions)?
    (stimuli = Stimuli)?
    ("timing" tmin=INT tmax=INT)?
  "}"
;

Conditions:
  'conditions' '{'
    // Parameter names are in the first line of condition specification
    varNames+=ID[eolterm]    // match var names until end of line
    // The rest of the description are conditions, one per line
    // The order of condition values match the param name positions.
    conditions+=Condition
  '}'
;

Condition:
  conditionVars+=ID[eolterm]  // match values until end of line
;

Stimuli:
  'stimuli' '{'
    stimuli+=Stimulus
  '}'
;

Stimulus:
  // Stimulus is given in the form of
  // condition match expression : stimulus definition
  conditionMatch=ConditionMatch ':' stimulusDef=StimulusDef
;

ConditionMatch:
  expression=ConditionMatchExpression
;

ConditionMatchExpression:
   FixedCondition|OrdinalCondition|ExpressionCondition
;

FixedCondition:
  expression = FixedConditionEnum
;

FixedConditionEnum:
  "any"|"error"|"fixation"|"correct"
;

OrdinalCondition:
  expression = INT
;

ExpressionCondition:
  expression = OrExpression
;

OrExpression: operand=AndExpression ('or' operand=AndExpression)*;
AndExpression: operand=NotEqualsExpression ('and' operand=NotEqualsExpression)*;

NotEqualsExpression:
  NotExpression | EqualsExpression;

NotExpression: 'not' operand=EqualsExpression;
EqualsExpression: varName=ID '=' varValue=ID;

/*
Expression(
  brackets=(),
  infixBinary=[Addition +, Substraction -, Multiplication *, Division /],
  unaryPrefix=[Negation -]
  presendence=[^, [*, /], [+, -]]
  assocRight=[^]
  operands=ID|FLOAT|INT
  )


ConditionMatchExpression expression:
    brackets=["(", ")"],
    infixBinary=[And 'and', Or 'or', Equals '='],
    prefixUnary=[Not 'not'],
    presendence=[Equals, Not, And, Or],
    operandMatch=ID
;
*/


StimulusDef:
  Image|Shape|Sound|Audio
;

Image:
  'image' '(' file=STRING
   (',' (('position' position=Position)|
      (duration=INT)|
      ('size' size=Size))*[','])?
  ')'
;

Shape:
  'shape' '(' shape=ShapeType
   (',' (('position' position=Position)|
      (duration=INT)|
      ('color' color=Color)|
      ('size' size=Size))*[','])?
  ')'
;

ShapeType:
  "rectangle"|"circle"|"triangle"|"cross"
;

Sound:
  'sound' '(' frequency=INT (',' duration=INT)? ')'
;

Audio:
  'audio' '(' file=STRING (',' duration=INT)? ')'
;

Color:
  "red"|"green"|"blue"|"yellow"|"white"|"black"
;

Size:
  ((descriptive=DescriptiveSize)|
  (x=INT y=INT)|
  (both=INT))
;

DescriptiveSize:
  "tiny"|"small"|"normal"|"large"|"huge"|"stratch"
;

Position:
  ((descriptive=PositionDescriptive)|
  (x=INT y=INT))
;

PositionDescriptive:
  "center"|"left"|"right"|"top"|"bottom"|"farLeft"|"farRight"|"farTop"|"farBottom"|
  "topLeft"|"topRight"|"bottomLeft"|"bottomRight"|
  "farTopLeft"|"farTopRight"|"farBottomLeft"|"farBottomRight"
;


Block:
  Sequence|Randomize
;

TestInstance:
  'test' type=[TestType] trials=INT (practice?="practice"|randomize?="randomize")*
;

TextInstance:
  'text' text=[TextType]
;

SubjectInstance:
  'subject' subject=[SubjectType]
;

Reference:
  TestInstance|TextInstance|SubjectInstance
;

ExperimentElement:
  Reference|Block
;


Experiment:
  'experiment' (name=STRING)? '{'
    elements*=ExperimentElement
  '}'
;

Sequence:
  'sequence' '{'
    elements*=ExperimentElement
  '}'
;

Randomize:
  'randomize' '{'
    elements*=ExperimentElement
  '}'
;

TextType:
  'text' name=ID "{"
    ('content'
      content=/(.|\n)*?(?=endcontent)/
    'endcontent')

    ('response' '=' ID)?

  '}'
;

SubjectType:
  'subject' name=ID '{'
    attribute+=SubjectAttribute
  '}'
;

SubjectAttribute:
  type=SubjectAttributeType name=ID (label=STRING)?
;

SubjectAttributeType:
  "int"|"string"|"float"|Enum
;

Enum:
  '[' values+=ID[','] ']'
;

Target:
  'target' name=ID '{'
    'output' '=' output=STRING
    'responses' '{'
        responseMap*=ResponseMap
    '}'
    targetParam*=TargetParam
  '}'
;

TargetParam:
  name=ID '=' value=BASETYPE
;

ResponseMap:
  name=ID '=' target=BASETYPE
;

// Special rule for comments
Comment:
  /\/\/.*$/|/\/\*(.|\n)*?\*\//  // Non-greedy match of block component content
;

